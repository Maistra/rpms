From 9277c928a034f8f8c65a03a0b06b9c0887beb0bf Mon Sep 17 00:00:00 2001
From: Kevin Conner <kconner@redhat.com>
Date: Sat, 8 Aug 2020 08:18:11 -0700
Subject: [PATCH] MAISTRA-1707: CVE-2020-16844


diff --git a/pilot/pkg/security/authz/model/matcher/string.go b/pilot/pkg/security/authz/model/matcher/string.go
index 450aac14f2..a73285e21f 100644
--- a/pilot/pkg/security/authz/model/matcher/string.go
+++ b/pilot/pkg/security/authz/model/matcher/string.go
@@ -43,11 +43,14 @@ func StringMatcherWithPrefix(v, prefix string, treatWildcardAsRequired bool) *en
 		}
 		return StringMatcherRegex(".*")
 	case strings.HasPrefix(v, "*"):
-		return &envoy_matcher.StringMatcher{
-			MatchPattern: &envoy_matcher.StringMatcher_Suffix{
-				Suffix: prefix + strings.TrimPrefix(v, "*"),
-			},
+		if prefix == "" {
+			return &envoy_matcher.StringMatcher{
+				MatchPattern: &envoy_matcher.StringMatcher_Suffix{
+					Suffix: strings.TrimPrefix(v, "*"),
+				},
+			}
 		}
+		return StringMatcherRegex(prefix + ".*" + strings.TrimPrefix(v, "*"))
 	case strings.HasSuffix(v, "*"):
 		return &envoy_matcher.StringMatcher{
 			MatchPattern: &envoy_matcher.StringMatcher_Prefix{
diff --git a/pilot/pkg/security/authz/model/matcher/string_test.go b/pilot/pkg/security/authz/model/matcher/string_test.go
index a0997ac801..1f5758113c 100644
--- a/pilot/pkg/security/authz/model/matcher/string_test.go
+++ b/pilot/pkg/security/authz/model/matcher/string_test.go
@@ -25,24 +25,27 @@ func TestStringMatcherWithPrefix(t *testing.T) {
 	testCases := []struct {
 		name                    string
 		v                       string
+		prefix                  string
 		treatWildcardAsRequired bool
 		want                    *envoy_matcher.StringMatcher
 	}{
 		{
 			name:                    "wildcardAsRequired",
 			v:                       "*",
+			prefix:                  "abc",
 			treatWildcardAsRequired: true,
 			want:                    StringMatcherRegex(".+"),
 		},
 		{
-			name:                    "wildcard",
-			v:                       "*",
-			treatWildcardAsRequired: false,
-			want:                    StringMatcherRegex(".*"),
+			name:   "wildcard",
+			v:      "*",
+			prefix: "abc",
+			want:   StringMatcherRegex(".*"),
 		},
 		{
-			name: "prefix",
-			v:    "-prefix-*",
+			name:   "prefix",
+			v:      "-prefix-*",
+			prefix: "abc",
 			want: &envoy_matcher.StringMatcher{
 				MatchPattern: &envoy_matcher.StringMatcher_Prefix{
 					Prefix: "abc-prefix-",
@@ -50,17 +53,25 @@ func TestStringMatcherWithPrefix(t *testing.T) {
 			},
 		},
 		{
-			name: "suffix",
-			v:    "*-suffix",
+			name:   "suffix-empty-prefix",
+			v:      "*-suffix",
+			prefix: "",
 			want: &envoy_matcher.StringMatcher{
 				MatchPattern: &envoy_matcher.StringMatcher_Suffix{
-					Suffix: "abc-suffix",
+					Suffix: "-suffix",
 				},
 			},
 		},
 		{
-			name: "exact",
-			v:    "-exact",
+			name:   "suffix",
+			v:      "*-suffix",
+			prefix: "abc",
+			want:   StringMatcherRegex("abc.*-suffix"),
+		},
+		{
+			name:   "exact",
+			v:      "-exact",
+			prefix: "abc",
 			want: &envoy_matcher.StringMatcher{
 				MatchPattern: &envoy_matcher.StringMatcher_Exact{
 					Exact: "abc-exact",
@@ -71,7 +82,7 @@ func TestStringMatcherWithPrefix(t *testing.T) {
 
 	for _, tc := range testCases {
 		t.Run(tc.name, func(t *testing.T) {
-			actual := StringMatcherWithPrefix(tc.v, "abc", tc.treatWildcardAsRequired)
+			actual := StringMatcherWithPrefix(tc.v, tc.prefix, tc.treatWildcardAsRequired)
 			if !reflect.DeepEqual(*actual, *tc.want) {
 				t.Errorf("want %s but got %s", tc.want.String(), actual.String())
 			}
diff --git a/pilot/pkg/security/authz/model/principal.go b/pilot/pkg/security/authz/model/principal.go
index 8a71665c66..81ee16821d 100644
--- a/pilot/pkg/security/authz/model/principal.go
+++ b/pilot/pkg/security/authz/model/principal.go
@@ -214,15 +214,13 @@ func (principal *Principal) forKeyValue(key, value string, forTCPFilter bool) *e
 		}
 		return principalSourceIP(cidr)
 	case attrSrcNamespace == key:
+		value = strings.Replace(value, "*", ".*", -1)
+		m := matcher.StringMatcherRegex(fmt.Sprintf(".*/ns/%s/.*", value))
 		if forTCPFilter {
-			regex := fmt.Sprintf(".*/ns/%s/.*", value)
-			m := matcher.StringMatcherRegex(regex)
 			return principalAuthenticated(m)
 		}
 		// Proxy doesn't have attrSrcNamespace directly, but the information is encoded in attrSrcPrincipal
 		// with format: cluster.local/ns/{NAMESPACE}/sa/{SERVICE-ACCOUNT}.
-		value = strings.Replace(value, "*", ".*", -1)
-		m := matcher.StringMatcherRegex(fmt.Sprintf(".*/ns/%s/.*", value))
 		metadata := matcher.MetadataStringMatcher(authn_model.AuthnFilterName, attrSrcPrincipal, m)
 		return principalMetadata(metadata)
 	case attrSrcPrincipal == key:
diff --git a/tests/integration/security/rbac_v1beta1_test.go b/tests/integration/security/rbac_v1beta1_test.go
index 099489a9df..7ded0c8d9d 100644
--- a/tests/integration/security/rbac_v1beta1_test.go
+++ b/tests/integration/security/rbac_v1beta1_test.go
@@ -15,6 +15,7 @@
 package security
 
 import (
+	"istio.io/istio/pkg/config/protocol"
 	"testing"
 
 	"istio.io/istio/pkg/test/echo/common/scheme"
@@ -333,3 +334,155 @@ func TestV1beta1_RequestHeaders(t *testing.T) {
 			rbacUtil.RunRBACTest(t, cases)
 		})
 }
+
+// TestV1beta1_TCP tests the authorization policy on workloads using the raw TCP protocol.
+func TestV1beta1_TCP(t *testing.T) {
+	framework.NewTest(t).
+		RequiresEnvironment(environment.Kube).
+		Run(func(ctx framework.TestContext) {
+			ns := namespace.NewOrFail(t, ctx, namespace.Config{
+				Prefix: "v1beta1-tcp-1",
+				Inject: true,
+			})
+			ns2 := namespace.NewOrFail(t, ctx, namespace.Config{
+				Prefix: "v1beta1-tcp-2",
+				Inject: true,
+			})
+			policy := tmpl.EvaluateAllOrFail(t, map[string]string{
+				"Namespace":  ns.Name(),
+				"Namespace2": ns2.Name(),
+			}, file.AsStringOrFail(t, "testdata/rbac/v1beta1-tcp.yaml.tmpl"))
+			g.ApplyConfigOrFail(t, nil, policy...)
+			defer g.DeleteConfigOrFail(t, nil, policy...)
+
+			var a, b, c, d, e, x echo.Instance
+			ports := []echo.Port{
+				{
+					Name:         "http-8090",
+					Protocol:     protocol.HTTP,
+					InstancePort: 8090,
+				},
+				{
+					Name:         "http-8091",
+					Protocol:     protocol.HTTP,
+					InstancePort: 8091,
+				},
+				{
+					Name:         "tcp-8092",
+					Protocol:     protocol.TCP,
+					InstancePort: 8092,
+				},
+				{
+					Name:         "tcp-8093",
+					Protocol:     protocol.TCP,
+					InstancePort: 8093,
+				},
+			}
+			echoboot.NewBuilderOrFail(t, ctx).
+				With(&x, util.EchoConfig("x", ns2, false, nil, g, p)).
+				With(&a, echo.Config{
+					Namespace:      ns,
+					Galley:         g,
+					Pilot:          p,
+					Service:        "a",
+					Ports:          ports,
+					ServiceAccount: true,
+				}).
+				With(&b, echo.Config{
+					Namespace:      ns,
+					Galley:         g,
+					Pilot:          p,
+					Service:        "b",
+					Ports:          ports,
+					ServiceAccount: true,
+				}).
+				With(&c, echo.Config{
+					Namespace:      ns,
+					Galley:         g,
+					Pilot:          p,
+					Service:        "c",
+					Ports:          ports,
+					ServiceAccount: true,
+				}).
+				With(&d, echo.Config{
+					Namespace:      ns,
+					Galley:         g,
+					Pilot:          p,
+					Service:        "d",
+					Ports:          ports,
+					ServiceAccount: true,
+				}).
+				With(&e, echo.Config{
+					Namespace:      ns,
+					Galley:         g,
+					Pilot:          p,
+					Service:        "e",
+					Ports:          ports,
+					ServiceAccount: true,
+				}).
+				BuildOrFail(t)
+
+			newTestCase := func(from, target echo.Instance, port string, expectAllowed bool) rbacUtil.TestCase {
+				return rbacUtil.TestCase{
+					Request: connection.Checker{
+						From: from,
+						Options: echo.CallOptions{
+							Target:   target,
+							PortName: port,
+							Scheme:   scheme.HTTP,
+							Path:     "/data",
+						},
+					},
+					ExpectAllowed: expectAllowed,
+				}
+			}
+
+			cases := []rbacUtil.TestCase{
+				// The policy on workload b denies request with path "/data" to port 8090:
+				// - request to port http-8090 should be denied because both path and port are matched.
+				// - request to port http-8091 should be allowed because the port is not matched.
+				// - request to port tcp-8092 should be allowed because the port is not matched.
+				newTestCase(a, b, "http-8090", false),
+				newTestCase(a, b, "http-8091", true),
+				newTestCase(a, b, "tcp-8092", true),
+
+				// The policy on workload c denies request to port 8090:
+				// - request to port http-8090 should be denied because the port is matched.
+				// - request to http port 8091 should be allowed because the port is not matched.
+				// - request to tcp port 8092 should be allowed because the port is not matched.
+				// - request from b to tcp port 8092 should be allowed by default.
+				// - request from b to tcp port 8093 should be denied because the principal is matched.
+				// - request from x to tcp port 8092 should be denied because the namespace is matched.
+				// - request from x to tcp port 8093 should be allowed by default.
+				newTestCase(a, c, "http-8090", false),
+				newTestCase(a, c, "http-8091", true),
+				newTestCase(a, c, "tcp-8092", true),
+				newTestCase(b, c, "tcp-8092", true),
+				newTestCase(b, c, "tcp-8093", false),
+				newTestCase(x, c, "tcp-8092", false),
+				newTestCase(x, c, "tcp-8093", true),
+
+				// The policy on workload d denies request from service account a and workloads in namespace 2:
+				// - request from a to d should be denied because it has service account a.
+				// - request from b to d should be allowed.
+				// - request from c to d should be allowed.
+				// - request from x to a should be allowed because there is no policy on a.
+				// - request from x to d should be denied because it's in namespace 2.
+				newTestCase(a, d, "tcp-8092", false),
+				newTestCase(b, d, "tcp-8092", true),
+				newTestCase(c, d, "tcp-8092", true),
+				newTestCase(x, a, "tcp-8092", true),
+				newTestCase(x, d, "tcp-8092", false),
+
+				// The policy on workload e denies request with path "/other":
+				// - request to port http-8090 should be allowed because the path is not matched.
+				// - request to port http-8091 should be allowed because the path is not matched.
+				// - request to port tcp-8092 should be denied because policy uses HTTP fields.
+				newTestCase(a, e, "http-8090", true),
+				newTestCase(a, e, "http-8091", true),
+				newTestCase(a, e, "tcp-8092", false),
+			}
+
+			rbacUtil.RunRBACTest(t, cases)
+		})
+}
diff --git a/tests/integration/security/util/rbac_util/util.go b/tests/integration/security/util/rbac_util/util.go
index 677ab6353b..dc5f13dd0a 100644
--- a/tests/integration/security/util/rbac_util/util.go
+++ b/tests/integration/security/util/rbac_util/util.go
@@ -69,7 +69,7 @@ func (tc TestCase) CheckRBACRequest() error {
 			return getError(req, "allow with code 200", fmt.Sprintf("error: %v", err))
 		}
 	} else {
-		if req.Options.PortName == "tcp" || req.Options.PortName == "grpc" {
+		if strings.HasPrefix(req.Options.PortName, "tcp") || req.Options.PortName == "grpc" {
 			expectedErrMsg := "EOF" // TCP deny message.
 			if req.Options.PortName == "grpc" {
 				expectedErrMsg = "rpc error: code = PermissionDenied desc = RBAC: access denied"
