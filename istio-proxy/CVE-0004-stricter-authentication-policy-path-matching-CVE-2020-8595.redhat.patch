From 32e2cbfa42077ea64e62904b2d24d33b2cd5f306 Mon Sep 17 00:00:00 2001
From: Kevin Conner <kconner@redhat.com>
Date: Thu, 6 Feb 2020 11:47:05 -0800
Subject: [PATCH] 
 CVE-0004-stricter-authentication-policy-path-matching-CVE-2020-8595


diff --git a/src/envoy/http/authn/origin_authenticator.cc b/src/envoy/http/authn/origin_authenticator.cc
index 6d517fa..f407556 100644
--- a/src/envoy/http/authn/origin_authenticator.cc
+++ b/src/envoy/http/authn/origin_authenticator.cc
@@ -44,10 +44,18 @@ bool OriginAuthenticator::run(Payload* payload) {
     return false;
   }
 
-  const char* request_path = nullptr;
+  bool pathNotPresent = true;
+  absl::string_view path;
   if (filter_context()->headerMap().Path() != nullptr) {
-    request_path = filter_context()->headerMap().Path()->value().c_str();
-    ENVOY_LOG(debug, "Got request path {}", request_path);
+    pathNotPresent = false;
+    path = filter_context()->headerMap().Path()->value().getStringView();
+
+    // Trim query parameters and/or fragment if present
+    size_t offset = path.find_first_of("?#");
+    if (offset != absl::string_view::npos) {
+      path.remove_suffix(path.length() - offset);
+    }
+    ENVOY_LOG(trace, "Got request path {}", path);
   } else {
     ENVOY_LOG(error,
               "Failed to get request path, JWT will always be used for "
@@ -59,8 +67,8 @@ bool OriginAuthenticator::run(Payload* payload) {
   for (const auto& method : policy_.origins()) {
     const auto& jwt = method.jwt();
 
-    if (AuthnUtils::ShouldValidateJwtPerPath(request_path, jwt)) {
-      ENVOY_LOG(debug, "Validating request path {} for jwt {}", request_path,
+    if (AuthnUtils::ShouldValidateJwtPerPath(pathNotPresent ? nullptr : std::string(path).c_str(), jwt)) {
+      ENVOY_LOG(debug, "Validating request path {} for jwt {}", path,
                 jwt.DebugString());
       // set triggered to true if any of the jwt trigger rule matched.
       triggered = true;
diff --git a/src/envoy/http/authn/origin_authenticator_test.cc b/src/envoy/http/authn/origin_authenticator_test.cc
index 7ed9b04..3029f50 100644
--- a/src/envoy/http/authn/origin_authenticator_test.cc
+++ b/src/envoy/http/authn/origin_authenticator_test.cc
@@ -100,6 +100,20 @@ const char kSingleOriginMethodWithTriggerRulePolicy[] = R"(
   }
 )";
 
+const char kSingleOriginMethodWithExcludeTriggerRulePolicy[] = R"(
+  principal_binding: USE_ORIGIN
+  origins {
+    jwt {
+      issuer: "abc.xyz"
+      trigger_rules: {
+        excluded_paths: {
+          exact: "/login"
+        }
+      }
+    }
+  }
+)";
+
 const char kMultipleOriginMethodWithTriggerRulePolicy[] = R"(
   principal_binding: USE_ORIGIN
   origins {
@@ -308,15 +322,60 @@ TEST_P(OriginAuthenticatorTest, SingleRuleTriggered) {
                                       filter_context_.authenticationResult()));
 }
 
+TEST_P(OriginAuthenticatorTest, SingleRuleTriggeredWithComponents) {
+  const std::vector<std::string> input_paths{"/allow?",
+                                             "/allow?a=b&c=d",
+                                             "/allow??",
+                                             "/allow??",
+                                             "/allow?#",
+                                             "/allow#?",
+                                             "/allow#a",
+                                             "/allow#$",
+                                             "/allow?a=b#c",
+                                             "/allow#a?b=c"};
+  for (const auto& path : input_paths) {
+    ASSERT_TRUE(Protobuf::TextFormat::ParseFromString(
+        kSingleOriginMethodWithTriggerRulePolicy, &policy_));
+
+    createAuthenticator();
+
+    EXPECT_CALL(*authenticator_, validateJwt(_, _))
+        .Times(1)
+        .WillOnce(DoAll(SetArgPointee<1>(jwt_payload_), Return(true)));
+
+    setPath(path);
+    EXPECT_TRUE(authenticator_->run(payload_));
+    EXPECT_TRUE(TestUtility::protoEqual(
+        expected_result_when_pass_, filter_context_.authenticationResult()));
+  }
+}
+
 TEST_P(OriginAuthenticatorTest, SingleRuleNotTriggered) {
+  const std::vector<std::string> input_paths{"/bad", "/allow$?", "/allow$#"};
+  for (const auto& path : input_paths) {
+    ASSERT_TRUE(Protobuf::TextFormat::ParseFromString(
+        kSingleOriginMethodWithTriggerRulePolicy, &policy_));
+
+    createAuthenticator();
+
+    EXPECT_CALL(*authenticator_, validateJwt(_, _)).Times(0);
+
+    setPath(path);
+    EXPECT_TRUE(authenticator_->run(payload_));
+    EXPECT_TRUE(TestUtility::protoEqual(
+        initial_result_, filter_context_.authenticationResult()));
+  }
+}
+
+TEST_P(OriginAuthenticatorTest, SingleExcludeRuleTriggeredWithQueryParam) {
   ASSERT_TRUE(Protobuf::TextFormat::ParseFromString(
-      kSingleOriginMethodWithTriggerRulePolicy, &policy_));
+      kSingleOriginMethodWithExcludeTriggerRulePolicy, &policy_));
 
   createAuthenticator();
 
   EXPECT_CALL(*authenticator_, validateJwt(_, _)).Times(0);
 
-  setPath("/bad");
+  setPath("/login?a=b&c=d");
   EXPECT_TRUE(authenticator_->run(payload_));
   EXPECT_TRUE(TestUtility::protoEqual(initial_result_,
                                       filter_context_.authenticationResult()));
