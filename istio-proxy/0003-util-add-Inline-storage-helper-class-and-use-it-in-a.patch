From 9512acce5357fa292b788393710becec629e65fc Mon Sep 17 00:00:00 2001
From: Joshua Marantz <jmarantz@google.com>
Date: Thu, 30 May 2019 20:11:53 -0400
Subject: [PATCH] util: add Inline storage helper-class and use it in a few
 places. (#7063)

* Add InlineStorage mixin supplying the allocation overrides needed to make it easier to create variable-size structures.

Signed-off-by: Joshua Marantz <jmarantz@google.com>
Signed-off-by: Piotr Sikora <piotrsikora@google.com>
---
 source/common/buffer/BUILD         |   1 +
 source/common/buffer/buffer_impl.h |  12 +----
 source/common/common/BUILD         |   1 +
 source/common/common/utility.cc    |   5 ++
 source/common/common/utility.h     | 108 +++++++++++++++++++++++++++++++++++++
 test/common/common/utility_test.cc |   6 +++
 tools/spelling_dictionary.txt      |   1 +
 7 files changed, 124 insertions(+), 10 deletions(-)

diff --git a/source/common/buffer/BUILD b/source/common/buffer/BUILD
index f4e6d96..ea7d665 100644
--- a/source/common/buffer/BUILD
+++ b/source/common/buffer/BUILD
@@ -26,6 +26,7 @@ envoy_cc_library(
         "//include/envoy/buffer:buffer_interface",
         "//source/common/common:non_copyable",
         "//source/common/common:stack_array",
+        "//source/common/common:utility_lib",
         "//source/common/event:libevent_lib",
     ],
 )
diff --git a/source/common/buffer/buffer_impl.h b/source/common/buffer/buffer_impl.h
index b09c077..83d390d 100644
--- a/source/common/buffer/buffer_impl.h
+++ b/source/common/buffer/buffer_impl.h
@@ -10,6 +10,7 @@
 
 #include "common/common/assert.h"
 #include "common/common/non_copyable.h"
+#include "common/common/utility.h"
 #include "common/event/libevent.h"
 
 namespace Envoy {
@@ -203,7 +204,7 @@ protected:
 
 using SlicePtr = std::unique_ptr<Slice>;
 
-class OwnedSlice : public Slice {
+class OwnedSlice : public Slice, public InlineStorage {
 public:
   /**
    * Create an empty OwnedSlice.
@@ -230,16 +231,7 @@ public:
     return slice;
   }
 
-  // Custom delete operator to keep C++14 from using the global operator delete(void*, size_t),
-  // which would result in the compiler error:
-  // "exception cleanup for this placement new selects non-placement operator delete"
-  static void operator delete(void* address) { ::operator delete(address); }
-
 private:
-  static void* operator new(size_t object_size, size_t data_size) {
-    return ::operator new(object_size + data_size);
-  }
-
   OwnedSlice(uint64_t size) : Slice(0, 0, size) { base_ = storage_; }
 
   /**
diff --git a/source/common/common/BUILD b/source/common/common/BUILD
index 156a52c..f24b513 100644
--- a/source/common/common/BUILD
+++ b/source/common/common/BUILD
@@ -238,6 +238,7 @@ envoy_cc_library(
     deps = [
         ":assert_lib",
         ":hash_lib",
+        ":non_copyable",
         "//include/envoy/common:interval_set_interface",
         "//include/envoy/common:time_interface",
         "//source/common/singleton:const_singleton",
diff --git a/source/common/common/utility.cc b/source/common/common/utility.cc
index f173d83..bb937f0 100644
--- a/source/common/common/utility.cc
+++ b/source/common/common/utility.cc
@@ -547,4 +547,9 @@ double WelfordStandardDeviation::computeStandardDeviation() const {
   return (std::isnan(variance) || variance < 0) ? std::nan("") : sqrt(variance);
 }
 
+InlineString::InlineString(const char* str, size_t size) : size_(size) {
+  RELEASE_ASSERT(size <= 0xffffffff, "size must fit in 32 bits");
+  memcpy(data_, str, size);
+}
+
 } // namespace Envoy
diff --git a/source/common/common/utility.h b/source/common/common/utility.h
index 785df6d..5ab6e41 100644
--- a/source/common/common/utility.h
+++ b/source/common/common/utility.h
@@ -14,6 +14,7 @@
 
 #include "common/common/assert.h"
 #include "common/common/hash.h"
+#include "common/common/non_copyable.h"
 
 #include "absl/strings/string_view.h"
 
@@ -602,4 +603,111 @@ template <class Value> struct TrieLookupTable {
   TrieEntry<Value> root_;
 };
 
+// Mix-in class for allocating classes with variable-sized inlined storage.
+//
+// Use this class by inheriting from it, ensuring that:
+//  - The variable sized array is declared as VarType[] as the last
+//    member variable of the class.
+//  - YourType accurately describes the type that will be stored there,
+//    to enable the compiler to perform correct alignment. No casting
+//    should be needed.
+//  - The class constructor is private, because you need to allocate the
+//    class the placed new operator exposed in the protected section below.
+//    Constructing the class directly will not provide space for the
+//    variable-size data.
+//  - You expose a public factory method that return a placement-new, e.g.
+//      static YourClass* alloc(size_t num_elements, constructor_args...) {
+//        new (num_elements * sizeof(VarType)) YourClass(constructor_args...);
+//      }
+//
+// See InlineString below for an example usage.
+//
+//
+// Perf note: The alignment will be correct and safe without further
+// consideration as long as there are no casts. But for micro-optimization,
+// consider this case:
+//   struct MyStruct : public InlineStorage { uint64_t a_; uint16_t b_; uint8_t data_[]; };
+// When compiled with a typical compiler on a 64-bit machine:
+//   sizeof(MyStruct) == 16, because the compiler will round up from 10 for uint64_t alignment.
+// So:
+//   calling new (6) MyStruct() causes an allocation of 16+6=22, rounded up to 24 bytes.
+// But data_ doesn't need 8-byte alignment, so it will wind up adjacent to the uint16_t.
+//   ((char*) my_struct.data) - ((char*) &my_struct) == 10
+// If we had instead declared data_[6], then the whole allocation would have fit in 16 bytes.
+// Instead:
+//   - the starting address of data will not be 8-byte aligned. This is not required
+//     by the C++ standard for a uint8_t, but may be suboptimal on some processors.
+//   - the 6 bytes of data will be at byte offsets 10 to 15, and bytes 16 to 23 will be
+//     unused. This may be surprising to some users, and suboptimal in resource usage.
+// One possible tweak is to declare data_ as a uint64_t[], or to use an `alignas`
+// declaration. As always, micro-optimizations should be informed by
+// microbenchmarks, showing the benefit.
+class InlineStorage : public NonCopyable {
+public:
+  // Custom delete operator to keep C++14 from using the global operator delete(void*, size_t),
+  // which would result in the compiler error:
+  // "exception cleanup for this placement new selects non-placement operator delete"
+  static void operator delete(void* address) { ::operator delete(address); }
+
+protected:
+  /**
+   * @param object_size the size of the base object; supplied automatically by the compiler.
+   * @param data_size the amount of variable-size storage to be added, in bytes.
+   * @return a variable-size object based on data_size_bytes.
+   */
+  static void* operator new(size_t object_size, size_t data_size_bytes) {
+    return ::operator new(object_size + data_size_bytes);
+  }
+};
+
+class InlineString;
+using InlineStringPtr = std::unique_ptr<InlineString>;
+
+// Represents immutable string data, keeping the storage inline with the
+// object. These cannot be copied or held by value; they must be created
+// as unique pointers.
+//
+// Note: this is not yet proven better (smaller or faster) than std::string for
+// all applications, but memory-size improvements have been measured for one
+// application (Stats::SymbolTableImpl). This is presented here to serve as an
+// example of how to use InlineStorage.
+class InlineString : public InlineStorage {
+public:
+  /**
+   * @param str the string_view for which to create an InlineString
+   * @return a unique_ptr to the InlineString containing the bytes of str.
+   */
+  static InlineStringPtr create(absl::string_view str) {
+    return InlineStringPtr(new (str.size()) InlineString(str.data(), str.size()));
+  }
+
+  /**
+   * @return a std::string copy of the InlineString.
+   */
+  std::string toString() const { return std::string(data_, size_); }
+
+  /**
+   * @return a string_view into the InlineString.
+   */
+  absl::string_view toStringView() const { return absl::string_view(data_, size_); }
+
+  /**
+   * @return the number of bytes in the string
+   */
+  size_t size() const { return size_; }
+
+  /**
+   * @return a pointer to the first byte of the string.
+   */
+  const char* data() const { return data_; }
+
+private:
+  // Constructor is declared private so that no one constructs one without the
+  // proper size allocation. to accommodate the variable-size buffer.
+  InlineString(const char* str, size_t size);
+
+  uint32_t size_;
+  char data_[];
+};
+
 } // namespace Envoy
diff --git a/test/common/common/utility_test.cc b/test/common/common/utility_test.cc
index 6434cd1..dbda67b 100644
--- a/test/common/common/utility_test.cc
+++ b/test/common/common/utility_test.cc
@@ -828,4 +828,10 @@ TEST(DateFormatter, FromTimeSameWildcard) {
             DateFormatter("%Y-%m-%dT%H:%M:%S.000Z%1f%2f").fromTime(time1));
 }
 
+TEST(InlineStorageTest, InlineString) {
+  InlineStringPtr hello = InlineString::create("Hello, world!");
+  EXPECT_EQ("Hello, world!", hello->toStringView());
+  EXPECT_EQ("Hello, world!", hello->toString());
+}
+
 } // namespace Envoy
diff --git a/tools/spelling_dictionary.txt b/tools/spelling_dictionary.txt
index b3d824f..8f4ef56 100644
--- a/tools/spelling_dictionary.txt
+++ b/tools/spelling_dictionary.txt
@@ -284,6 +284,7 @@ accessors
 acls
 addr
 agg
+alignas
 alloc
 alloca
 allocator
-- 
1.8.3.1

