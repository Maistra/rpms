From b87e5d32a4729c9fabf300d18087aeac46797fd3 Mon Sep 17 00:00:00 2001
From: Kevin Conner <kconner@redhat.com>
Date: Tue, 3 Dec 2019 15:20:31 -0800
Subject: [PATCH] route-config-handle-no-host-path-headers-CVE-2019-18838.patch


diff --git a/source/common/router/config_impl.cc b/source/common/router/config_impl.cc
index d17e0e56f..86bcc9b58 100644
--- a/source/common/router/config_impl.cc
+++ b/source/common/router/config_impl.cc
@@ -423,6 +423,12 @@ bool RouteEntryImplBase::evaluateRuntimeMatch(const uint64_t random_value) const
 bool RouteEntryImplBase::matchRoute(const Http::HeaderMap& headers, uint64_t random_value) const {
   bool matches = true;
 
+  // TODO(mattklein123): Currently all match types require a path header. When we support CONNECT
+  // we will need to figure out how to safely relax this.
+  if (headers.Path() == nullptr) {
+    return false;
+  }
+
   matches &= evaluateRuntimeMatch(random_value);
   if (!matches) {
     // No need to waste further cycles calculating a route match.
@@ -1024,6 +1030,11 @@ const VirtualHostImpl* RouteMatcher::findVirtualHost(const Http::HeaderMap& head
     return default_virtual_host_.get();
   }
 
+  // There may be no authority in early reply paths in the HTTP connection manager.
+  if (headers.Host() == nullptr) {
+    return nullptr;
+  }
+
   // TODO (@rshriram) Match Origin header in WebSocket
   // request with VHost, using wildcard match
   const std::string host = Http::LowerCaseString(headers.Host()->value().c_str()).get();
diff --git a/test/common/router/config_impl_test.cc b/test/common/router/config_impl_test.cc
index 86d5bd0fa..62c044f8f 100644
--- a/test/common/router/config_impl_test.cc
+++ b/test/common/router/config_impl_test.cc
@@ -277,6 +277,17 @@ virtual_hosts:
   NiceMock<Envoy::StreamInfo::MockStreamInfo> stream_info;
   TestConfigImpl config(parseRouteConfigurationFromV2Yaml(yaml), factory_context_, true);
 
+  // No host header, no x-forwarded-proto and no path header testing.
+  EXPECT_EQ(nullptr, config.route(Http::TestHeaderMapImpl{{":path", "/"}, {":method", "GET"}}, 0));
+  EXPECT_EQ(
+      nullptr,
+      config.route(
+          Http::TestHeaderMapImpl{{":authority", "foo"}, {":path", "/"}, {":method", "GET"}}, 0));
+  EXPECT_EQ(nullptr, config.route(Http::TestHeaderMapImpl{{":authority", "foo"},
+                                                          {":method", "CONNECT"},
+                                                          {"x-forwarded-proto", "http"}},
+                                  0));
+
   // Base routing testing.
   EXPECT_EQ("instant-server",
             config.route(genHeaders("api.lyft.com", "/", "GET"), 0)->routeEntry()->clusterName());
diff --git a/test/common/router/route_fuzz_test.cc b/test/common/router/route_fuzz_test.cc
index f12de7a78..3acfa790e 100644
--- a/test/common/router/route_fuzz_test.cc
+++ b/test/common/router/route_fuzz_test.cc
@@ -19,17 +19,6 @@ DEFINE_PROTO_FUZZER(const test::common::router::RouteTestCase& input) {
     MessageUtil::validate(input.config());
     ConfigImpl config(input.config(), factory_context, true);
     Http::TestHeaderMapImpl headers = Fuzz::fromHeaders(input.headers());
-    // It's a precondition of routing that {:authority, :path, x-forwarded-proto} headers exists,
-    // HCM enforces this.
-    if (headers.Host() == nullptr) {
-      headers.insertHost().value(std::string("example.com"));
-    }
-    if (headers.Path() == nullptr) {
-      headers.insertPath().value(std::string("/"));
-    }
-    if (headers.ForwardedProto() == nullptr) {
-      headers.insertForwardedProto().value(std::string("http"));
-    }
     auto route = config.route(headers, input.random_value());
     if (route != nullptr && route->routeEntry() != nullptr) {
       route->routeEntry()->finalizeRequestHeaders(headers, stream_info, true);
diff --git a/test/extensions/filters/http/lua/lua_integration_test.cc b/test/extensions/filters/http/lua/lua_integration_test.cc
index 73e5db0d2..e0c96799a 100644
--- a/test/extensions/filters/http/lua/lua_integration_test.cc
+++ b/test/extensions/filters/http/lua/lua_integration_test.cc
@@ -21,7 +21,7 @@ public:
         new FakeUpstream(0, FakeHttpConnection::Type::HTTP1, version_, timeSystem()));
   }
 
-  void initializeFilter(const std::string& filter_config) {
+  void initializeFilter(const std::string& filter_config, const std::string& domain = "*") {
     config_helper_.addFilter(filter_config);
 
     config_helper_.addConfigModifier([](envoy::config::bootstrap::v2::Bootstrap& bootstrap) {
@@ -35,14 +35,15 @@ public:
     });
 
     config_helper_.addConfigModifier(
-        [](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager&
-               hcm) {
+        [domain](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager&
+                     hcm) {
           hcm.mutable_route_config()
               ->mutable_virtual_hosts(0)
               ->mutable_routes(0)
               ->mutable_match()
               ->set_prefix("/test/long/url");
 
+          hcm.mutable_route_config()->mutable_virtual_hosts(0)->set_domains(0, domain);
           auto* new_route = hcm.mutable_route_config()->mutable_virtual_hosts(0)->add_routes();
           new_route->mutable_match()->set_prefix("/alt/route");
           new_route->mutable_route()->set_cluster("alt_cluster");
@@ -97,6 +98,32 @@ INSTANTIATE_TEST_SUITE_P(IpVersions, LuaIntegrationTest,
                          testing::ValuesIn(TestEnvironment::getIpVersionsForTest()),
                          TestUtility::ipTestParamsToString);
 
+// Regression test for pulling route info during early local replies using the Lua filter
+// metadata() API. Covers both the upgrade required and no authority cases.
+TEST_P(LuaIntegrationTest, CallMetadataDuringLocalReply) {
+  const std::string FILTER_AND_CODE =
+      R"EOF(
+name: envoy.lua
+typed_config:
+  "@type": type.googleapis.com/envoy.config.filter.http.lua.v2.Lua
+  inline_code: |
+    function envoy_on_response(response_handle)
+      local metadata = response_handle:metadata():get("foo.bar")
+      if metadata == nil then
+      end
+    end
+)EOF";
+
+  initializeFilter(FILTER_AND_CODE, "foo");
+  std::string response;
+  sendRawHttpAndWaitForResponse(lookupPort("http"), "GET / HTTP/1.0\r\n\r\n", &response, true);
+  EXPECT_TRUE(response.find("HTTP/1.1 426 Upgrade Required\r\n") == 0);
+
+  response = "";
+  sendRawHttpAndWaitForResponse(lookupPort("http"), "GET / HTTP/1.1\r\n\r\n", &response, true);
+  EXPECT_TRUE(response.find("HTTP/1.1 400 Bad Request\r\n") == 0);
+}
+
 // Basic request and response.
 TEST_P(LuaIntegrationTest, RequestAndResponse) {
   const std::string FILTER_AND_CODE =
